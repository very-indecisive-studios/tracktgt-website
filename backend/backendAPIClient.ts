//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import dayjs from "dayjs";
export class ExtBackendAPIClient {
    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        options.headers = {
            ...options.headers
            // TODO: Add private API token to Bearer header. 
        }

        return options;
    }
}

export class BackendAPIClient extends ExtBackendAPIClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    book_AddBookWishlist(addBookWishlistCommand: AddBookWishlistCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/book/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addBookWishlistCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_AddBookWishlist(_response);
        });
    }

    protected processBook_AddBookWishlist(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_RemoveBookWishlist(removeBookWishlistCommand: RemoveBookWishlistCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/book/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeBookWishlistCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_RemoveBookWishlist(_response);
        });
    }

    protected processBook_RemoveBookWishlist(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_GetAllBookWishlists(userRemoteId: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllBookWishlistsItemResult>> {
        let url_ = this.baseUrl + "/api/book/wishlist?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_GetAllBookWishlists(_response);
        });
    }

    protected processBook_GetAllBookWishlists(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllBookWishlistsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllBookWishlistsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllBookWishlistsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_GetBookWishlist(userRemoteId: string | null, bookRemoteId: string | null): Promise<BackendAPIResponse<boolean>> {
        let url_ = this.baseUrl + "/api/book/wishlist/{userRemoteId}/{bookRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (bookRemoteId === undefined || bookRemoteId === null)
            throw new Error("The parameter 'bookRemoteId' must be defined.");
        url_ = url_.replace("{bookRemoteId}", encodeURIComponent("" + bookRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_GetBookWishlist(_response);
        });
    }

    protected processBook_GetBookWishlist(response: Response): Promise<BackendAPIResponse<boolean>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<boolean>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_AddBookTracking(addBookTrackingCommand: AddBookTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/book/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addBookTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_AddBookTracking(_response);
        });
    }

    protected processBook_AddBookTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_RemoveBookTracking(removeBookTrackingCommand: RemoveBookTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/book/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeBookTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_RemoveBookTracking(_response);
        });
    }

    protected processBook_RemoveBookTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_UpdateBookTracking(updateBookTrackingCommand: UpdateBookTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/book/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateBookTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_UpdateBookTracking(_response);
        });
    }

    protected processBook_UpdateBookTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_GetAllBookTrackings(userRemoteId: string | null | undefined, bookStatus: BookTrackingStatus | null | undefined, sortByRecentlyModified: boolean | undefined, sortByChaptersRead: boolean | undefined, sortByFormat: boolean | undefined, sortByOwnership: boolean | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllBookTrackingsItemResult>> {
        let url_ = this.baseUrl + "/api/book/track?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (bookStatus !== undefined && bookStatus !== null)
            url_ += "BookStatus=" + encodeURIComponent("" + bookStatus) + "&";
        if (sortByRecentlyModified === null)
            throw new Error("The parameter 'sortByRecentlyModified' cannot be null.");
        else if (sortByRecentlyModified !== undefined)
            url_ += "SortByRecentlyModified=" + encodeURIComponent("" + sortByRecentlyModified) + "&";
        if (sortByChaptersRead === null)
            throw new Error("The parameter 'sortByChaptersRead' cannot be null.");
        else if (sortByChaptersRead !== undefined)
            url_ += "SortByChaptersRead=" + encodeURIComponent("" + sortByChaptersRead) + "&";
        if (sortByFormat === null)
            throw new Error("The parameter 'sortByFormat' cannot be null.");
        else if (sortByFormat !== undefined)
            url_ += "SortByFormat=" + encodeURIComponent("" + sortByFormat) + "&";
        if (sortByOwnership === null)
            throw new Error("The parameter 'sortByOwnership' cannot be null.");
        else if (sortByOwnership !== undefined)
            url_ += "SortByOwnership=" + encodeURIComponent("" + sortByOwnership) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_GetAllBookTrackings(_response);
        });
    }

    protected processBook_GetAllBookTrackings(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllBookTrackingsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllBookTrackingsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllBookTrackingsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_GetBookTracking(userRemoteId: string | null, bookRemoteId: string | null): Promise<BackendAPIResponse<GetBookTrackingResult>> {
        let url_ = this.baseUrl + "/api/book/track/{userRemoteId}/{bookRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (bookRemoteId === undefined || bookRemoteId === null)
            throw new Error("The parameter 'bookRemoteId' must be defined.");
        url_ = url_.replace("{bookRemoteId}", encodeURIComponent("" + bookRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_GetBookTracking(_response);
        });
    }

    protected processBook_GetBookTracking(response: Response): Promise<BackendAPIResponse<GetBookTrackingResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBookTrackingResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetBookTrackingResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_GetBook(id: string | null): Promise<BackendAPIResponse<GetBookResult>> {
        let url_ = this.baseUrl + "/api/book/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_GetBook(_response);
        });
    }

    protected processBook_GetBook(response: Response): Promise<BackendAPIResponse<GetBookResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBookResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetBookResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    book_SearchBooks(title: string | null | undefined): Promise<BackendAPIResponse<SearchBooksResult>> {
        let url_ = this.baseUrl + "/api/book/search?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBook_SearchBooks(_response);
        });
    }

    protected processBook_SearchBooks(response: Response): Promise<BackendAPIResponse<SearchBooksResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchBooksResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<SearchBooksResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_AddGameWishlist(addGameWishlistCommand: AddGameWishlistCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addGameWishlistCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_AddGameWishlist(_response);
        });
    }

    protected processGame_AddGameWishlist(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_RemoveGameWishlist(removeGameWishlistCommand: RemoveGameWishlistCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeGameWishlistCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_RemoveGameWishlist(_response);
        });
    }

    protected processGame_RemoveGameWishlist(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetAllGameWishlists(userRemoteId: string | null | undefined, sortByPlatform: boolean | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllGameWishlistsItemResult>> {
        let url_ = this.baseUrl + "/api/game/wishlist?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (sortByPlatform === null)
            throw new Error("The parameter 'sortByPlatform' cannot be null.");
        else if (sortByPlatform !== undefined)
            url_ += "SortByPlatform=" + encodeURIComponent("" + sortByPlatform) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetAllGameWishlists(_response);
        });
    }

    protected processGame_GetAllGameWishlists(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllGameWishlistsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllGameWishlistsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllGameWishlistsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetGameWishlists(userRemoteId: string | null, gameRemoteId: number): Promise<BackendAPIResponse<GetGameWishlistsResult>> {
        let url_ = this.baseUrl + "/api/game/wishlist/{userRemoteId}/{gameRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (gameRemoteId === undefined || gameRemoteId === null)
            throw new Error("The parameter 'gameRemoteId' must be defined.");
        url_ = url_.replace("{gameRemoteId}", encodeURIComponent("" + gameRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGameWishlists(_response);
        });
    }

    protected processGame_GetGameWishlists(response: Response): Promise<BackendAPIResponse<GetGameWishlistsResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGameWishlistsResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetGameWishlistsResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_AddGameTracking(addGameTrackingCommand: AddGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_AddGameTracking(_response);
        });
    }

    protected processGame_AddGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_RemoveGameTracking(removeGameTrackingCommand: RemoveGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_RemoveGameTracking(_response);
        });
    }

    protected processGame_RemoveGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_UpdateGameTracking(updateGameTrackingCommand: UpdateGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_UpdateGameTracking(_response);
        });
    }

    protected processGame_UpdateGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetAllGameTrackings(userRemoteId: string | null | undefined, gameStatus: GameTrackingStatus | null | undefined, sortByRecentlyModified: boolean | undefined, sortByHoursPlayed: boolean | undefined, sortByPlatform: boolean | undefined, sortByFormat: boolean | undefined, sortByOwnership: boolean | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>> {
        let url_ = this.baseUrl + "/api/game/track?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (gameStatus !== undefined && gameStatus !== null)
            url_ += "GameStatus=" + encodeURIComponent("" + gameStatus) + "&";
        if (sortByRecentlyModified === null)
            throw new Error("The parameter 'sortByRecentlyModified' cannot be null.");
        else if (sortByRecentlyModified !== undefined)
            url_ += "SortByRecentlyModified=" + encodeURIComponent("" + sortByRecentlyModified) + "&";
        if (sortByHoursPlayed === null)
            throw new Error("The parameter 'sortByHoursPlayed' cannot be null.");
        else if (sortByHoursPlayed !== undefined)
            url_ += "SortByHoursPlayed=" + encodeURIComponent("" + sortByHoursPlayed) + "&";
        if (sortByPlatform === null)
            throw new Error("The parameter 'sortByPlatform' cannot be null.");
        else if (sortByPlatform !== undefined)
            url_ += "SortByPlatform=" + encodeURIComponent("" + sortByPlatform) + "&";
        if (sortByFormat === null)
            throw new Error("The parameter 'sortByFormat' cannot be null.");
        else if (sortByFormat !== undefined)
            url_ += "SortByFormat=" + encodeURIComponent("" + sortByFormat) + "&";
        if (sortByOwnership === null)
            throw new Error("The parameter 'sortByOwnership' cannot be null.");
        else if (sortByOwnership !== undefined)
            url_ += "SortByOwnership=" + encodeURIComponent("" + sortByOwnership) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetAllGameTrackings(_response);
        });
    }

    protected processGame_GetAllGameTrackings(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllGameTrackingsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetGameTrackings(userRemoteId: string | null, gameRemoteId: number): Promise<BackendAPIResponse<GetGameTrackingsResult>> {
        let url_ = this.baseUrl + "/api/game/track/{userRemoteId}/{gameRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (gameRemoteId === undefined || gameRemoteId === null)
            throw new Error("The parameter 'gameRemoteId' must be defined.");
        url_ = url_.replace("{gameRemoteId}", encodeURIComponent("" + gameRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGameTrackings(_response);
        });
    }

    protected processGame_GetGameTrackings(response: Response): Promise<BackendAPIResponse<GetGameTrackingsResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGameTrackingsResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetGameTrackingsResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetGame(id: number): Promise<BackendAPIResponse<GetGameResult>> {
        let url_ = this.baseUrl + "/api/game/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGame(_response);
        });
    }

    protected processGame_GetGame(response: Response): Promise<BackendAPIResponse<GetGameResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGameResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetGameResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_SearchGames(title: string | null | undefined): Promise<BackendAPIResponse<SearchGamesResult>> {
        let url_ = this.baseUrl + "/api/game/search?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_SearchGames(_response);
        });
    }

    protected processGame_SearchGames(response: Response): Promise<BackendAPIResponse<SearchGamesResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchGamesResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<SearchGamesResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    price_GetSwitchGamePrice(region: string | null, id: number): Promise<BackendAPIResponse<GetSwitchGamePriceResult>> {
        let url_ = this.baseUrl + "/api/price/switch/{region}/{id}";
        if (region === undefined || region === null)
            throw new Error("The parameter 'region' must be defined.");
        url_ = url_.replace("{region}", encodeURIComponent("" + region));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPrice_GetSwitchGamePrice(_response);
        });
    }

    protected processPrice_GetSwitchGamePrice(response: Response): Promise<BackendAPIResponse<GetSwitchGamePriceResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSwitchGamePriceResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetSwitchGamePriceResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    price_GetSwitchGameStoreRegions(): Promise<BackendAPIResponse<GetSwitchGameStoreRegionsResult>> {
        let url_ = this.baseUrl + "/api/price/switch/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPrice_GetSwitchGameStoreRegions(_response);
        });
    }

    protected processPrice_GetSwitchGameStoreRegions(response: Response): Promise<BackendAPIResponse<GetSwitchGameStoreRegionsResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSwitchGameStoreRegionsResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetSwitchGameStoreRegionsResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_AddShowTracking(addShowTrackingCommand: AddShowTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/show/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addShowTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_AddShowTracking(_response);
        });
    }

    protected processShow_AddShowTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_RemoveShowTracking(removeShowTrackingCommand: RemoveShowTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/show/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeShowTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_RemoveShowTracking(_response);
        });
    }

    protected processShow_RemoveShowTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_UpdateShowTracking(updateShowTrackingCommand: UpdateShowTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/show/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateShowTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_UpdateShowTracking(_response);
        });
    }

    protected processShow_UpdateShowTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_GetAllShowTrackings(userRemoteId: string | null | undefined, status: ShowTrackingStatus | null | undefined, sortByRecentlyModified: boolean | undefined, sortByEpisodesWatched: boolean | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllShowTrackingsItemResult>> {
        let url_ = this.baseUrl + "/api/show/track?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sortByRecentlyModified === null)
            throw new Error("The parameter 'sortByRecentlyModified' cannot be null.");
        else if (sortByRecentlyModified !== undefined)
            url_ += "SortByRecentlyModified=" + encodeURIComponent("" + sortByRecentlyModified) + "&";
        if (sortByEpisodesWatched === null)
            throw new Error("The parameter 'sortByEpisodesWatched' cannot be null.");
        else if (sortByEpisodesWatched !== undefined)
            url_ += "SortByEpisodesWatched=" + encodeURIComponent("" + sortByEpisodesWatched) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_GetAllShowTrackings(_response);
        });
    }

    protected processShow_GetAllShowTrackings(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllShowTrackingsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllShowTrackingsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllShowTrackingsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_GetShowTracking(userRemoteId: string | null, showRemoteId: string | null): Promise<BackendAPIResponse<GetShowTrackingResult>> {
        let url_ = this.baseUrl + "/api/show/track/{userRemoteId}/{showRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (showRemoteId === undefined || showRemoteId === null)
            throw new Error("The parameter 'showRemoteId' must be defined.");
        url_ = url_.replace("{showRemoteId}", encodeURIComponent("" + showRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_GetShowTracking(_response);
        });
    }

    protected processShow_GetShowTracking(response: Response): Promise<BackendAPIResponse<GetShowTrackingResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetShowTrackingResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetShowTrackingResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_GetShow(id: string | null): Promise<BackendAPIResponse<GetShowResult>> {
        let url_ = this.baseUrl + "/api/show/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_GetShow(_response);
        });
    }

    protected processShow_GetShow(response: Response): Promise<BackendAPIResponse<GetShowResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetShowResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetShowResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    show_SearchShows(title: string | null | undefined): Promise<BackendAPIResponse<SearchShowsResult>> {
        let url_ = this.baseUrl + "/api/show/search?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShow_SearchShows(_response);
        });
    }

    protected processShow_SearchShows(response: Response): Promise<BackendAPIResponse<SearchShowsResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchShowsResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<SearchShowsResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_RegisterUser(command: RegisterUserCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_RegisterUser(_response);
        });
    }

    protected processUser_RegisterUser(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_CheckUserExist(userName: string | null | undefined, email: string | null | undefined): Promise<BackendAPIResponse<CheckUserExistResult>> {
        let url_ = this.baseUrl + "/api/user/checkuserexist?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_CheckUserExist(_response);
        });
    }

    protected processUser_CheckUserExist(response: Response): Promise<BackendAPIResponse<CheckUserExistResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckUserExistResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<CheckUserExistResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_GetUser(userRemoteId: string | null): Promise<BackendAPIResponse<GetUserResult>> {
        let url_ = this.baseUrl + "/api/user/{userRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_GetUser(_response);
        });
    }

    protected processUser_GetUser(response: Response): Promise<BackendAPIResponse<GetUserResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetUserResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_GetPricingUserPreference(userRemoteId: string | null): Promise<BackendAPIResponse<GetPricingUserPreferenceResult>> {
        let url_ = this.baseUrl + "/api/user/preferences/pricing/{userRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_GetPricingUserPreference(_response);
        });
    }

    protected processUser_GetPricingUserPreference(response: Response): Promise<BackendAPIResponse<GetPricingUserPreferenceResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPricingUserPreferenceResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetPricingUserPreferenceResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_UpdatePricingUserPreferenceCommand(command: UpdatePricingUserPreferenceCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/user/preferences/pricing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_UpdatePricingUserPreferenceCommand(_response);
        });
    }

    protected processUser_UpdatePricingUserPreferenceCommand(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUnit {
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class AddBookWishlistCommand implements IAddBookWishlistCommand {
    userRemoteId!: string;
    bookRemoteId!: string;

    constructor(data?: IAddBookWishlistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.bookRemoteId = _data["bookRemoteId"];
        }
    }

    static fromJS(data: any): AddBookWishlistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddBookWishlistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["bookRemoteId"] = this.bookRemoteId;
        return data;
    }
}

export interface IAddBookWishlistCommand {
    userRemoteId: string;
    bookRemoteId: string;
}

export class RemoveBookWishlistCommand implements IRemoveBookWishlistCommand {
    userRemoteId!: string;
    bookRemoteId!: string;

    constructor(data?: IRemoveBookWishlistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.bookRemoteId = _data["bookRemoteId"];
        }
    }

    static fromJS(data: any): RemoveBookWishlistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveBookWishlistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["bookRemoteId"] = this.bookRemoteId;
        return data;
    }
}

export interface IRemoveBookWishlistCommand {
    userRemoteId: string;
    bookRemoteId: string;
}

export class PagedListResultOfGetAllBookWishlistsItemResult implements IPagedListResultOfGetAllBookWishlistsItemResult {
    page!: number;
    totalPages!: number;
    pageSize!: number;
    currentPageSize!: number;
    currentStartIndex!: number;
    currentEndIndex!: number;
    totalCount!: number;
    hasPrevious!: boolean;
    hasNext!: boolean;
    items!: GetAllBookWishlistsItemResult[];

    constructor(data?: IPagedListResultOfGetAllBookWishlistsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllBookWishlistsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllBookWishlistsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllBookWishlistsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllBookWishlistsItemResult {
    page: number;
    totalPages: number;
    pageSize: number;
    currentPageSize: number;
    currentStartIndex: number;
    currentEndIndex: number;
    totalCount: number;
    hasPrevious: boolean;
    hasNext: boolean;
    items: GetAllBookWishlistsItemResult[];
}

export class GetAllBookWishlistsItemResult implements IGetAllBookWishlistsItemResult {
    bookRemoteId!: string;
    title!: string;
    coverImageURL!: string;

    constructor(data?: IGetAllBookWishlistsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookRemoteId = _data["bookRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
        }
    }

    static fromJS(data: any): GetAllBookWishlistsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBookWishlistsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookRemoteId"] = this.bookRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        return data;
    }
}

export interface IGetAllBookWishlistsItemResult {
    bookRemoteId: string;
    title: string;
    coverImageURL: string;
}

export class AddBookTrackingCommand implements IAddBookTrackingCommand {
    userRemoteId!: string;
    bookRemoteId!: string;
    chaptersRead!: number;
    format!: BookTrackingFormat;
    status!: BookTrackingStatus;
    ownership!: BookTrackingOwnership;

    constructor(data?: IAddBookTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.bookRemoteId = _data["bookRemoteId"];
            this.chaptersRead = _data["chaptersRead"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): AddBookTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddBookTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["bookRemoteId"] = this.bookRemoteId;
        data["chaptersRead"] = this.chaptersRead;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IAddBookTrackingCommand {
    userRemoteId: string;
    bookRemoteId: string;
    chaptersRead: number;
    format: BookTrackingFormat;
    status: BookTrackingStatus;
    ownership: BookTrackingOwnership;
}

export enum BookTrackingFormat {
    Digital = 0,
    Physical = 1,
}

export enum BookTrackingStatus {
    Completed = 0,
    Reading = 1,
    Paused = 2,
    Planning = 3,
}

export enum BookTrackingOwnership {
    Owned = 0,
    Loan = 1,
}

export class RemoveBookTrackingCommand implements IRemoveBookTrackingCommand {
    userRemoteId!: string;
    bookRemoteId!: string;

    constructor(data?: IRemoveBookTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.bookRemoteId = _data["bookRemoteId"];
        }
    }

    static fromJS(data: any): RemoveBookTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveBookTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["bookRemoteId"] = this.bookRemoteId;
        return data;
    }
}

export interface IRemoveBookTrackingCommand {
    userRemoteId: string;
    bookRemoteId: string;
}

export class UpdateBookTrackingCommand implements IUpdateBookTrackingCommand {
    userRemoteId!: string;
    bookRemoteId!: string;
    chaptersRead!: number;
    format!: BookTrackingFormat;
    status!: BookTrackingStatus;
    ownership!: BookTrackingOwnership;

    constructor(data?: IUpdateBookTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.bookRemoteId = _data["bookRemoteId"];
            this.chaptersRead = _data["chaptersRead"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): UpdateBookTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["bookRemoteId"] = this.bookRemoteId;
        data["chaptersRead"] = this.chaptersRead;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IUpdateBookTrackingCommand {
    userRemoteId: string;
    bookRemoteId: string;
    chaptersRead: number;
    format: BookTrackingFormat;
    status: BookTrackingStatus;
    ownership: BookTrackingOwnership;
}

export class PagedListResultOfGetAllBookTrackingsItemResult implements IPagedListResultOfGetAllBookTrackingsItemResult {
    page!: number;
    totalPages!: number;
    pageSize!: number;
    currentPageSize!: number;
    currentStartIndex!: number;
    currentEndIndex!: number;
    totalCount!: number;
    hasPrevious!: boolean;
    hasNext!: boolean;
    items!: GetAllBookTrackingsItemResult[];

    constructor(data?: IPagedListResultOfGetAllBookTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllBookTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllBookTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllBookTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllBookTrackingsItemResult {
    page: number;
    totalPages: number;
    pageSize: number;
    currentPageSize: number;
    currentStartIndex: number;
    currentEndIndex: number;
    totalCount: number;
    hasPrevious: boolean;
    hasNext: boolean;
    items: GetAllBookTrackingsItemResult[];
}

export class GetAllBookTrackingsItemResult implements IGetAllBookTrackingsItemResult {
    bookRemoteId!: string;
    title!: string;
    coverImageURL!: string;
    chaptersRead!: number;
    format!: BookTrackingFormat;
    status!: BookTrackingStatus;
    ownership!: BookTrackingOwnership;

    constructor(data?: IGetAllBookTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookRemoteId = _data["bookRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.chaptersRead = _data["chaptersRead"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetAllBookTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBookTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookRemoteId"] = this.bookRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["chaptersRead"] = this.chaptersRead;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetAllBookTrackingsItemResult {
    bookRemoteId: string;
    title: string;
    coverImageURL: string;
    chaptersRead: number;
    format: BookTrackingFormat;
    status: BookTrackingStatus;
    ownership: BookTrackingOwnership;
}

export class GetBookTrackingResult implements IGetBookTrackingResult {
    chaptersRead!: number;
    format!: BookTrackingFormat;
    status!: BookTrackingStatus;
    ownership!: BookTrackingOwnership;

    constructor(data?: IGetBookTrackingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chaptersRead = _data["chaptersRead"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetBookTrackingResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookTrackingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chaptersRead"] = this.chaptersRead;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetBookTrackingResult {
    chaptersRead: number;
    format: BookTrackingFormat;
    status: BookTrackingStatus;
    ownership: BookTrackingOwnership;
}

export class GetBookResult implements IGetBookResult {
    remoteId!: string;
    coverImageURL!: string;
    title!: string;
    summary!: string;
    authors!: string[];

    constructor(data?: IGetBookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.coverImageURL = _data["coverImageURL"];
            this.title = _data["title"];
            this.summary = _data["summary"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(item);
            }
        }
    }

    static fromJS(data: any): GetBookResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["coverImageURL"] = this.coverImageURL;
        data["title"] = this.title;
        data["summary"] = this.summary;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item);
        }
        return data;
    }
}

export interface IGetBookResult {
    remoteId: string;
    coverImageURL: string;
    title: string;
    summary: string;
    authors: string[];
}

export class SearchBooksResult implements ISearchBooksResult {
    items!: SearchBooksItemResult[];

    constructor(data?: ISearchBooksResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchBooksItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchBooksResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBooksResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchBooksResult {
    items: SearchBooksItemResult[];
}

export class SearchBooksItemResult implements ISearchBooksItemResult {
    remoteId!: string;
    title!: string;
    coverImageURL!: string;
    authors!: string[];

    constructor(data?: ISearchBooksItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchBooksItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBooksItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item);
        }
        return data;
    }
}

export interface ISearchBooksItemResult {
    remoteId: string;
    title: string;
    coverImageURL: string;
    authors: string[];
}

export class AddGameWishlistCommand implements IAddGameWishlistCommand {
    userRemoteId!: string;
    gameRemoteId!: number;
    platform!: string;

    constructor(data?: IAddGameWishlistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): AddGameWishlistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddGameWishlistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        return data;
    }
}

export interface IAddGameWishlistCommand {
    userRemoteId: string;
    gameRemoteId: number;
    platform: string;
}

export class RemoveGameWishlistCommand implements IRemoveGameWishlistCommand {
    userRemoteId!: string;
    gameRemoteId!: number;
    platform!: string;

    constructor(data?: IRemoveGameWishlistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): RemoveGameWishlistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveGameWishlistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        return data;
    }
}

export interface IRemoveGameWishlistCommand {
    userRemoteId: string;
    gameRemoteId: number;
    platform: string;
}

export class PagedListResultOfGetAllGameWishlistsItemResult implements IPagedListResultOfGetAllGameWishlistsItemResult {
    page!: number;
    totalPages!: number;
    pageSize!: number;
    currentPageSize!: number;
    currentStartIndex!: number;
    currentEndIndex!: number;
    totalCount!: number;
    hasPrevious!: boolean;
    hasNext!: boolean;
    items!: GetAllGameWishlistsItemResult[];

    constructor(data?: IPagedListResultOfGetAllGameWishlistsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllGameWishlistsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllGameWishlistsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllGameWishlistsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllGameWishlistsItemResult {
    page: number;
    totalPages: number;
    pageSize: number;
    currentPageSize: number;
    currentStartIndex: number;
    currentEndIndex: number;
    totalCount: number;
    hasPrevious: boolean;
    hasNext: boolean;
    items: GetAllGameWishlistsItemResult[];
}

export class GetAllGameWishlistsItemResult implements IGetAllGameWishlistsItemResult {
    gameRemoteId!: number;
    title!: string;
    coverImageURL!: string;
    platform!: string;

    constructor(data?: IGetAllGameWishlistsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameRemoteId = _data["gameRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): GetAllGameWishlistsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllGameWishlistsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameRemoteId"] = this.gameRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["platform"] = this.platform;
        return data;
    }
}

export interface IGetAllGameWishlistsItemResult {
    gameRemoteId: number;
    title: string;
    coverImageURL: string;
    platform: string;
}

export class GetGameWishlistsResult implements IGetGameWishlistsResult {
    items!: GetGameWishlistItemResult[];

    constructor(data?: IGetGameWishlistsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetGameWishlistItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGameWishlistsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameWishlistsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetGameWishlistsResult {
    items: GetGameWishlistItemResult[];
}

export class GetGameWishlistItemResult implements IGetGameWishlistItemResult {
    platform!: string;

    constructor(data?: IGetGameWishlistItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): GetGameWishlistItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameWishlistItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platform"] = this.platform;
        return data;
    }
}

export interface IGetGameWishlistItemResult {
    platform: string;
}

export class AddGameTrackingCommand implements IAddGameTrackingCommand {
    userRemoteId!: string;
    gameRemoteId!: number;
    hoursPlayed!: number;
    platform!: string;
    format!: GameTrackingFormat;
    status!: GameTrackingStatus;
    ownership!: GameTrackingOwnership;

    constructor(data?: IAddGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): AddGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IAddGameTrackingCommand {
    userRemoteId: string;
    gameRemoteId: number;
    hoursPlayed: number;
    platform: string;
    format: GameTrackingFormat;
    status: GameTrackingStatus;
    ownership: GameTrackingOwnership;
}

export enum GameTrackingFormat {
    Digital = 0,
    Physical = 1,
}

export enum GameTrackingStatus {
    Completed = 0,
    Playing = 1,
    Paused = 2,
    Planning = 3,
}

export enum GameTrackingOwnership {
    Owned = 0,
    Loan = 1,
    Subscription = 2,
}

export class RemoveGameTrackingCommand implements IRemoveGameTrackingCommand {
    userRemoteId!: string;
    gameRemoteId!: number;
    platform!: string;

    constructor(data?: IRemoveGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): RemoveGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        return data;
    }
}

export interface IRemoveGameTrackingCommand {
    userRemoteId: string;
    gameRemoteId: number;
    platform: string;
}

export class UpdateGameTrackingCommand implements IUpdateGameTrackingCommand {
    userRemoteId!: string;
    gameRemoteId!: number;
    platform!: string;
    hoursPlayed!: number;
    format!: GameTrackingFormat;
    status!: GameTrackingStatus;
    ownership!: GameTrackingOwnership;

    constructor(data?: IUpdateGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): UpdateGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        data["hoursPlayed"] = this.hoursPlayed;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IUpdateGameTrackingCommand {
    userRemoteId: string;
    gameRemoteId: number;
    platform: string;
    hoursPlayed: number;
    format: GameTrackingFormat;
    status: GameTrackingStatus;
    ownership: GameTrackingOwnership;
}

export class PagedListResultOfGetAllGameTrackingsItemResult implements IPagedListResultOfGetAllGameTrackingsItemResult {
    page!: number;
    totalPages!: number;
    pageSize!: number;
    currentPageSize!: number;
    currentStartIndex!: number;
    currentEndIndex!: number;
    totalCount!: number;
    hasPrevious!: boolean;
    hasNext!: boolean;
    items!: GetAllGameTrackingsItemResult[];

    constructor(data?: IPagedListResultOfGetAllGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllGameTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllGameTrackingsItemResult {
    page: number;
    totalPages: number;
    pageSize: number;
    currentPageSize: number;
    currentStartIndex: number;
    currentEndIndex: number;
    totalCount: number;
    hasPrevious: boolean;
    hasNext: boolean;
    items: GetAllGameTrackingsItemResult[];
}

export class GetAllGameTrackingsItemResult implements IGetAllGameTrackingsItemResult {
    gameRemoteId!: number;
    title!: string;
    coverImageURL!: string;
    hoursPlayed!: number;
    platform!: string;
    format!: GameTrackingFormat;
    status!: GameTrackingStatus;
    ownership!: GameTrackingOwnership;

    constructor(data?: IGetAllGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameRemoteId = _data["gameRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetAllGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameRemoteId"] = this.gameRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetAllGameTrackingsItemResult {
    gameRemoteId: number;
    title: string;
    coverImageURL: string;
    hoursPlayed: number;
    platform: string;
    format: GameTrackingFormat;
    status: GameTrackingStatus;
    ownership: GameTrackingOwnership;
}

export class GetGameTrackingsResult implements IGetGameTrackingsResult {
    items!: GetGameTrackingsItemResult[];

    constructor(data?: IGetGameTrackingsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetGameTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGameTrackingsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameTrackingsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetGameTrackingsResult {
    items: GetGameTrackingsItemResult[];
}

export class GetGameTrackingsItemResult implements IGetGameTrackingsItemResult {
    hoursPlayed!: number;
    platform!: string;
    format!: GameTrackingFormat;
    status!: GameTrackingStatus;
    ownership!: GameTrackingOwnership;

    constructor(data?: IGetGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetGameTrackingsItemResult {
    hoursPlayed: number;
    platform: string;
    format: GameTrackingFormat;
    status: GameTrackingStatus;
    ownership: GameTrackingOwnership;
}

export class GetGameResult implements IGetGameResult {
    remoteId!: number;
    coverImageURL!: string;
    title!: string;
    summary!: string;
    rating!: number;
    platforms!: string[];
    companies!: string[];

    constructor(data?: IGetGameResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.platforms = [];
            this.companies = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.coverImageURL = _data["coverImageURL"];
            this.title = _data["title"];
            this.summary = _data["summary"];
            this.rating = _data["rating"];
            if (Array.isArray(_data["platforms"])) {
                this.platforms = [] as any;
                for (let item of _data["platforms"])
                    this.platforms!.push(item);
            }
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies!.push(item);
            }
        }
    }

    static fromJS(data: any): GetGameResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["coverImageURL"] = this.coverImageURL;
        data["title"] = this.title;
        data["summary"] = this.summary;
        data["rating"] = this.rating;
        if (Array.isArray(this.platforms)) {
            data["platforms"] = [];
            for (let item of this.platforms)
                data["platforms"].push(item);
        }
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item);
        }
        return data;
    }
}

export interface IGetGameResult {
    remoteId: number;
    coverImageURL: string;
    title: string;
    summary: string;
    rating: number;
    platforms: string[];
    companies: string[];
}

export class SearchGamesResult implements ISearchGamesResult {
    items!: SearchGamesItemResult[];

    constructor(data?: ISearchGamesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchGamesItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchGamesResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchGamesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchGamesResult {
    items: SearchGamesItemResult[];
}

export class SearchGamesItemResult implements ISearchGamesItemResult {
    remoteId!: number;
    title!: string;
    coverImageURL!: string;
    platforms!: string[];

    constructor(data?: ISearchGamesItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.platforms = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            if (Array.isArray(_data["platforms"])) {
                this.platforms = [] as any;
                for (let item of _data["platforms"])
                    this.platforms!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchGamesItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchGamesItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        if (Array.isArray(this.platforms)) {
            data["platforms"] = [];
            for (let item of this.platforms)
                data["platforms"].push(item);
        }
        return data;
    }
}

export interface ISearchGamesItemResult {
    remoteId: number;
    title: string;
    coverImageURL: string;
    platforms: string[];
}

export class GetSwitchGamePriceResult implements IGetSwitchGamePriceResult {
    url!: string;
    currency!: string;
    price!: number;
    isOnSale!: boolean;
    saleEnd?: dayjs.Dayjs | undefined;

    constructor(data?: IGetSwitchGamePriceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.currency = _data["currency"];
            this.price = _data["price"];
            this.isOnSale = _data["isOnSale"];
            this.saleEnd = _data["saleEnd"] ? dayjs(_data["saleEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSwitchGamePriceResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSwitchGamePriceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["currency"] = this.currency;
        data["price"] = this.price;
        data["isOnSale"] = this.isOnSale;
        data["saleEnd"] = this.saleEnd ? this.saleEnd.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetSwitchGamePriceResult {
    url: string;
    currency: string;
    price: number;
    isOnSale: boolean;
    saleEnd?: dayjs.Dayjs | undefined;
}

export class GetSwitchGameStoreRegionsResult implements IGetSwitchGameStoreRegionsResult {
    regions!: string[];

    constructor(data?: IGetSwitchGameStoreRegionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.regions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetSwitchGameStoreRegionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSwitchGameStoreRegionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item);
        }
        return data;
    }
}

export interface IGetSwitchGameStoreRegionsResult {
    regions: string[];
}

export class AddShowTrackingCommand implements IAddShowTrackingCommand {
    userRemoteId!: string;
    showRemoteId!: string;
    episodesWatched!: number;
    showType!: ShowType;
    status!: ShowTrackingStatus;

    constructor(data?: IAddShowTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.showRemoteId = _data["showRemoteId"];
            this.episodesWatched = _data["episodesWatched"];
            this.showType = _data["showType"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AddShowTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddShowTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["showRemoteId"] = this.showRemoteId;
        data["episodesWatched"] = this.episodesWatched;
        data["showType"] = this.showType;
        data["status"] = this.status;
        return data;
    }
}

export interface IAddShowTrackingCommand {
    userRemoteId: string;
    showRemoteId: string;
    episodesWatched: number;
    showType: ShowType;
    status: ShowTrackingStatus;
}

export enum ShowType {
    Movie = 0,
    Series = 1,
}

export enum ShowTrackingStatus {
    Completed = 0,
    Watching = 1,
    Paused = 2,
    Planning = 3,
}

export class RemoveShowTrackingCommand implements IRemoveShowTrackingCommand {
    userRemoteId!: string;
    showRemoteId!: string;
    showType!: ShowType;

    constructor(data?: IRemoveShowTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.showRemoteId = _data["showRemoteId"];
            this.showType = _data["showType"];
        }
    }

    static fromJS(data: any): RemoveShowTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveShowTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["showRemoteId"] = this.showRemoteId;
        data["showType"] = this.showType;
        return data;
    }
}

export interface IRemoveShowTrackingCommand {
    userRemoteId: string;
    showRemoteId: string;
    showType: ShowType;
}

export class UpdateShowTrackingCommand implements IUpdateShowTrackingCommand {
    userRemoteId!: string;
    showRemoteId!: string;
    episodesWatched!: number;
    status!: ShowTrackingStatus;

    constructor(data?: IUpdateShowTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.showRemoteId = _data["showRemoteId"];
            this.episodesWatched = _data["episodesWatched"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateShowTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShowTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["showRemoteId"] = this.showRemoteId;
        data["episodesWatched"] = this.episodesWatched;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateShowTrackingCommand {
    userRemoteId: string;
    showRemoteId: string;
    episodesWatched: number;
    status: ShowTrackingStatus;
}

export class PagedListResultOfGetAllShowTrackingsItemResult implements IPagedListResultOfGetAllShowTrackingsItemResult {
    page!: number;
    totalPages!: number;
    pageSize!: number;
    currentPageSize!: number;
    currentStartIndex!: number;
    currentEndIndex!: number;
    totalCount!: number;
    hasPrevious!: boolean;
    hasNext!: boolean;
    items!: GetAllShowTrackingsItemResult[];

    constructor(data?: IPagedListResultOfGetAllShowTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllShowTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllShowTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllShowTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllShowTrackingsItemResult {
    page: number;
    totalPages: number;
    pageSize: number;
    currentPageSize: number;
    currentStartIndex: number;
    currentEndIndex: number;
    totalCount: number;
    hasPrevious: boolean;
    hasNext: boolean;
    items: GetAllShowTrackingsItemResult[];
}

export class GetAllShowTrackingsItemResult implements IGetAllShowTrackingsItemResult {
    showRemoteId!: string;
    title!: string;
    coverImageURL!: string;
    episodesWatched!: number;
    showType!: ShowType;
    status!: ShowTrackingStatus;

    constructor(data?: IGetAllShowTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showRemoteId = _data["showRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.episodesWatched = _data["episodesWatched"];
            this.showType = _data["showType"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetAllShowTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllShowTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showRemoteId"] = this.showRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["episodesWatched"] = this.episodesWatched;
        data["showType"] = this.showType;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetAllShowTrackingsItemResult {
    showRemoteId: string;
    title: string;
    coverImageURL: string;
    episodesWatched: number;
    showType: ShowType;
    status: ShowTrackingStatus;
}

export class GetShowTrackingResult implements IGetShowTrackingResult {
    episodesWatched!: number;
    showType!: ShowType;
    status!: ShowTrackingStatus;

    constructor(data?: IGetShowTrackingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.episodesWatched = _data["episodesWatched"];
            this.showType = _data["showType"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetShowTrackingResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetShowTrackingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episodesWatched"] = this.episodesWatched;
        data["showType"] = this.showType;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetShowTrackingResult {
    episodesWatched: number;
    showType: ShowType;
    status: ShowTrackingStatus;
}

export class GetShowResult implements IGetShowResult {
    remoteId!: string;
    coverImageURL!: string;
    title!: string;
    summary!: string;
    showType!: ShowType;

    constructor(data?: IGetShowResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.coverImageURL = _data["coverImageURL"];
            this.title = _data["title"];
            this.summary = _data["summary"];
            this.showType = _data["showType"];
        }
    }

    static fromJS(data: any): GetShowResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetShowResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["coverImageURL"] = this.coverImageURL;
        data["title"] = this.title;
        data["summary"] = this.summary;
        data["showType"] = this.showType;
        return data;
    }
}

export interface IGetShowResult {
    remoteId: string;
    coverImageURL: string;
    title: string;
    summary: string;
    showType: ShowType;
}

export class SearchShowsResult implements ISearchShowsResult {
    items!: SearchShowsItemResult[];

    constructor(data?: ISearchShowsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchShowsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchShowsResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchShowsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchShowsResult {
    items: SearchShowsItemResult[];
}

export class SearchShowsItemResult implements ISearchShowsItemResult {
    remoteId!: string;
    title!: string;
    coverImageURL!: string;
    showType!: ShowType;

    constructor(data?: ISearchShowsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.showType = _data["showType"];
        }
    }

    static fromJS(data: any): SearchShowsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchShowsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["showType"] = this.showType;
        return data;
    }
}

export interface ISearchShowsItemResult {
    remoteId: string;
    title: string;
    coverImageURL: string;
    showType: ShowType;
}

export class RegisterUserCommand implements IRegisterUserCommand {
    userRemoteId!: string;
    email!: string;
    userName!: string;

    constructor(data?: IRegisterUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.email = _data["email"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): RegisterUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["email"] = this.email;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IRegisterUserCommand {
    userRemoteId: string;
    email: string;
    userName: string;
}

export class CheckUserExistResult implements ICheckUserExistResult {
    isUserNameTaken!: boolean;
    isEmailTaken!: boolean;

    constructor(data?: ICheckUserExistResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameTaken = _data["isUserNameTaken"];
            this.isEmailTaken = _data["isEmailTaken"];
        }
    }

    static fromJS(data: any): CheckUserExistResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserExistResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameTaken"] = this.isUserNameTaken;
        data["isEmailTaken"] = this.isEmailTaken;
        return data;
    }
}

export interface ICheckUserExistResult {
    isUserNameTaken: boolean;
    isEmailTaken: boolean;
}

export class GetUserResult implements IGetUserResult {
    userName!: string;
    email!: string;

    constructor(data?: IGetUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetUserResult {
    userName: string;
    email: string;
}

export class GetPricingUserPreferenceResult implements IGetPricingUserPreferenceResult {
    eShopRegion!: string;

    constructor(data?: IGetPricingUserPreferenceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eShopRegion = _data["eShopRegion"];
        }
    }

    static fromJS(data: any): GetPricingUserPreferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetPricingUserPreferenceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eShopRegion"] = this.eShopRegion;
        return data;
    }
}

export interface IGetPricingUserPreferenceResult {
    eShopRegion: string;
}

export class UpdatePricingUserPreferenceCommand implements IUpdatePricingUserPreferenceCommand {
    userRemoteId!: string;
    eShopRegion!: string;

    constructor(data?: IUpdatePricingUserPreferenceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.eShopRegion = _data["eShopRegion"];
        }
    }

    static fromJS(data: any): UpdatePricingUserPreferenceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePricingUserPreferenceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["eShopRegion"] = this.eShopRegion;
        return data;
    }
}

export interface IUpdatePricingUserPreferenceCommand {
    userRemoteId: string;
    eShopRegion: string;
}

export class BackendAPIResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class BackendAPIException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isBackendAPIException = true;

    static isBackendAPIException(obj: any): obj is BackendAPIException {
        return obj.isBackendAPIException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new BackendAPIException(message, status, response, headers, null);
}