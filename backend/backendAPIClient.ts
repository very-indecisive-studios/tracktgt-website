//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import * as dayjs from 'dayjs';

export class ExtBackendAPIClient {
    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        options.headers = {
            ...options.headers
            // TODO: Add private API token to Bearer header. 
        }

        return options;
    }
}

export class BackendAPIClient extends ExtBackendAPIClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    game_AddGameTracking(addGameTrackingCommand: AddGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_AddGameTracking(_response);
        });
    }

    protected processGame_AddGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_RemoveGameTracking(removeGameTrackingCommand: RemoveGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_RemoveGameTracking(_response);
        });
    }

    protected processGame_RemoveGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_UpdateGameTracking(updateGameTrackingCommand: UpdateGameTrackingCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/game/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateGameTrackingCommand);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_UpdateGameTracking(_response);
        });
    }

    protected processGame_UpdateGameTracking(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetAllGameTrackings(userRemoteId: string | null | undefined, gameStatus: GameTrackingStatus | null | undefined, sortByRecentlyModified: boolean | undefined, sortByHoursPlayed: boolean | undefined, sortByPlatform: boolean | undefined, sortByFormat: boolean | undefined, sortByOwnership: boolean | undefined, page: number | undefined, pageSize: number | undefined): Promise<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>> {
        let url_ = this.baseUrl + "/api/game/track?";
        if (userRemoteId !== undefined && userRemoteId !== null)
            url_ += "UserRemoteId=" + encodeURIComponent("" + userRemoteId) + "&";
        if (gameStatus !== undefined && gameStatus !== null)
            url_ += "GameStatus=" + encodeURIComponent("" + gameStatus) + "&";
        if (sortByRecentlyModified === null)
            throw new Error("The parameter 'sortByRecentlyModified' cannot be null.");
        else if (sortByRecentlyModified !== undefined)
            url_ += "SortByRecentlyModified=" + encodeURIComponent("" + sortByRecentlyModified) + "&";
        if (sortByHoursPlayed === null)
            throw new Error("The parameter 'sortByHoursPlayed' cannot be null.");
        else if (sortByHoursPlayed !== undefined)
            url_ += "SortByHoursPlayed=" + encodeURIComponent("" + sortByHoursPlayed) + "&";
        if (sortByPlatform === null)
            throw new Error("The parameter 'sortByPlatform' cannot be null.");
        else if (sortByPlatform !== undefined)
            url_ += "SortByPlatform=" + encodeURIComponent("" + sortByPlatform) + "&";
        if (sortByFormat === null)
            throw new Error("The parameter 'sortByFormat' cannot be null.");
        else if (sortByFormat !== undefined)
            url_ += "SortByFormat=" + encodeURIComponent("" + sortByFormat) + "&";
        if (sortByOwnership === null)
            throw new Error("The parameter 'sortByOwnership' cannot be null.");
        else if (sortByOwnership !== undefined)
            url_ += "SortByOwnership=" + encodeURIComponent("" + sortByOwnership) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetAllGameTrackings(_response);
        });
    }

    protected processGame_GetAllGameTrackings(response: Response): Promise<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListResultOfGetAllGameTrackingsItemResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<PagedListResultOfGetAllGameTrackingsItemResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetGameTrackings(userRemoteId: string | null, gameRemoteId: number): Promise<BackendAPIResponse<GetGameTrackingsResult>> {
        let url_ = this.baseUrl + "/api/game/track/{userRemoteId}/{gameRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        if (gameRemoteId === undefined || gameRemoteId === null)
            throw new Error("The parameter 'gameRemoteId' must be defined.");
        url_ = url_.replace("{gameRemoteId}", encodeURIComponent("" + gameRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGameTrackings(_response);
        });
    }

    protected processGame_GetGameTrackings(response: Response): Promise<BackendAPIResponse<GetGameTrackingsResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGameTrackingsResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetGameTrackingsResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_GetGame(id: number): Promise<BackendAPIResponse<GetGameResult>> {
        let url_ = this.baseUrl + "/api/game/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGame(_response);
        });
    }

    protected processGame_GetGame(response: Response): Promise<BackendAPIResponse<GetGameResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGameResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetGameResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    game_SearchGames(title: string | null | undefined): Promise<BackendAPIResponse<SearchGamesResult>> {
        let url_ = this.baseUrl + "/api/game/search?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_SearchGames(_response);
        });
    }

    protected processGame_SearchGames(response: Response): Promise<BackendAPIResponse<SearchGamesResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchGamesResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<SearchGamesResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_RegisterUser(command: RegisterUserCommand): Promise<BackendAPIResponse<Unit>> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_RegisterUser(_response);
        });
    }

    protected processUser_RegisterUser(response: Response): Promise<BackendAPIResponse<Unit>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<Unit>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_CheckUserExist(userName: string | null | undefined, email: string | null | undefined): Promise<BackendAPIResponse<CheckUserExistResult>> {
        let url_ = this.baseUrl + "/api/user/checkuserexist?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_CheckUserExist(_response);
        });
    }

    protected processUser_CheckUserExist(response: Response): Promise<BackendAPIResponse<CheckUserExistResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckUserExistResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<CheckUserExistResult>>(new BackendAPIResponse(status, _headers, null as any));
    }

    user_GetUser(userRemoteId: string | null): Promise<BackendAPIResponse<GetUserResult>> {
        let url_ = this.baseUrl + "/api/user/user/{userRemoteId}";
        if (userRemoteId === undefined || userRemoteId === null)
            throw new Error("The parameter 'userRemoteId' must be defined.");
        url_ = url_.replace("{userRemoteId}", encodeURIComponent("" + userRemoteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUser_GetUser(_response);
        });
    }

    protected processUser_GetUser(response: Response): Promise<BackendAPIResponse<GetUserResult>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserResult.fromJS(resultData200);
            return new BackendAPIResponse(status, _headers, result200);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackendAPIResponse<GetUserResult>>(new BackendAPIResponse(status, _headers, null as any));
    }
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUnit {
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class AddGameTrackingCommand implements IAddGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;

    constructor(data?: IAddGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): AddGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IAddGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;
}

export enum GameTrackingFormat {
    Digital = 0,
    Physical = 1,
    None = 2,
}

export enum GameTrackingStatus {
    Completed = 0,
    Playing = 1,
    Paused = 2,
    Planning = 3,
}

export enum GameTrackingOwnership {
    Owned = 0,
    Loan = 1,
    Wishlist = 2,
    Subscription = 3,
}

export class RemoveGameTrackingCommand implements IRemoveGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    platform?: string;

    constructor(data?: IRemoveGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
        }
    }

    static fromJS(data: any): RemoveGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        return data;
    }
}

export interface IRemoveGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    platform?: string;
}

export class UpdateGameTrackingCommand implements IUpdateGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    platform?: string;
    hoursPlayed?: number;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;

    constructor(data?: IUpdateGameTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRemoteId = _data["userRemoteId"];
            this.gameRemoteId = _data["gameRemoteId"];
            this.platform = _data["platform"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): UpdateGameTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGameTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRemoteId"] = this.userRemoteId;
        data["gameRemoteId"] = this.gameRemoteId;
        data["platform"] = this.platform;
        data["hoursPlayed"] = this.hoursPlayed;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IUpdateGameTrackingCommand {
    userRemoteId?: string;
    gameRemoteId?: number;
    platform?: string;
    hoursPlayed?: number;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;
}

export class PagedListResultOfGetAllGameTrackingsItemResult implements IPagedListResultOfGetAllGameTrackingsItemResult {
    page?: number;
    totalPages?: number;
    pageSize?: number;
    currentPageSize?: number;
    currentStartIndex?: number;
    currentEndIndex?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: GetAllGameTrackingsItemResult[];

    constructor(data?: IPagedListResultOfGetAllGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.currentPageSize = _data["currentPageSize"];
            this.currentStartIndex = _data["currentStartIndex"];
            this.currentEndIndex = _data["currentEndIndex"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllGameTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListResultOfGetAllGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfGetAllGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["currentPageSize"] = this.currentPageSize;
        data["currentStartIndex"] = this.currentStartIndex;
        data["currentEndIndex"] = this.currentEndIndex;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListResultOfGetAllGameTrackingsItemResult {
    page?: number;
    totalPages?: number;
    pageSize?: number;
    currentPageSize?: number;
    currentStartIndex?: number;
    currentEndIndex?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: GetAllGameTrackingsItemResult[];
}

export class GetAllGameTrackingsItemResult implements IGetAllGameTrackingsItemResult {
    gameRemoteId?: number;
    title?: string;
    coverImageURL?: string;
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;

    constructor(data?: IGetAllGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameRemoteId = _data["gameRemoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetAllGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameRemoteId"] = this.gameRemoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetAllGameTrackingsItemResult {
    gameRemoteId?: number;
    title?: string;
    coverImageURL?: string;
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;
}

export class GetGameTrackingsResult implements IGetGameTrackingsResult {
    items?: GetGameTrackingsItemResult[];

    constructor(data?: IGetGameTrackingsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetGameTrackingsItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGameTrackingsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameTrackingsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetGameTrackingsResult {
    items?: GetGameTrackingsItemResult[];
}

export class GetGameTrackingsItemResult implements IGetGameTrackingsItemResult {
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;

    constructor(data?: IGetGameTrackingsItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hoursPlayed = _data["hoursPlayed"];
            this.platform = _data["platform"];
            this.format = _data["format"];
            this.status = _data["status"];
            this.ownership = _data["ownership"];
        }
    }

    static fromJS(data: any): GetGameTrackingsItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameTrackingsItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoursPlayed"] = this.hoursPlayed;
        data["platform"] = this.platform;
        data["format"] = this.format;
        data["status"] = this.status;
        data["ownership"] = this.ownership;
        return data;
    }
}

export interface IGetGameTrackingsItemResult {
    hoursPlayed?: number;
    platform?: string;
    format?: GameTrackingFormat;
    status?: GameTrackingStatus;
    ownership?: GameTrackingOwnership;
}

export class GetGameResult implements IGetGameResult {
    remoteId?: number;
    coverImageURL?: string;
    title?: string;
    summary?: string;
    rating?: number;
    platforms?: string[] | undefined;
    companies?: string[] | undefined;

    constructor(data?: IGetGameResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.coverImageURL = _data["coverImageURL"];
            this.title = _data["title"];
            this.summary = _data["summary"];
            this.rating = _data["rating"];
            if (Array.isArray(_data["platforms"])) {
                this.platforms = [] as any;
                for (let item of _data["platforms"])
                    this.platforms!.push(item);
            }
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies!.push(item);
            }
        }
    }

    static fromJS(data: any): GetGameResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["coverImageURL"] = this.coverImageURL;
        data["title"] = this.title;
        data["summary"] = this.summary;
        data["rating"] = this.rating;
        if (Array.isArray(this.platforms)) {
            data["platforms"] = [];
            for (let item of this.platforms)
                data["platforms"].push(item);
        }
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item);
        }
        return data;
    }
}

export interface IGetGameResult {
    remoteId?: number;
    coverImageURL?: string;
    title?: string;
    summary?: string;
    rating?: number;
    platforms?: string[] | undefined;
    companies?: string[] | undefined;
}

export class SearchGamesResult implements ISearchGamesResult {
    items?: SearchGamesItemResult[];

    constructor(data?: ISearchGamesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchGamesItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchGamesResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchGamesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchGamesResult {
    items?: SearchGamesItemResult[];
}

export class SearchGamesItemResult implements ISearchGamesItemResult {
    remoteId?: number;
    title?: string;
    coverImageURL?: string;
    platforms?: string[];

    constructor(data?: ISearchGamesItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteId = _data["remoteId"];
            this.title = _data["title"];
            this.coverImageURL = _data["coverImageURL"];
            if (Array.isArray(_data["platforms"])) {
                this.platforms = [] as any;
                for (let item of _data["platforms"])
                    this.platforms!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchGamesItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchGamesItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteId"] = this.remoteId;
        data["title"] = this.title;
        data["coverImageURL"] = this.coverImageURL;
        if (Array.isArray(this.platforms)) {
            data["platforms"] = [];
            for (let item of this.platforms)
                data["platforms"].push(item);
        }
        return data;
    }
}

export interface ISearchGamesItemResult {
    remoteId?: number;
    title?: string;
    coverImageURL?: string;
    platforms?: string[];
}

export class RegisterUserCommand implements IRegisterUserCommand {
    remoteUserId?: string;
    email?: string;
    userName?: string;

    constructor(data?: IRegisterUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remoteUserId = _data["remoteUserId"];
            this.email = _data["email"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): RegisterUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remoteUserId"] = this.remoteUserId;
        data["email"] = this.email;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IRegisterUserCommand {
    remoteUserId?: string;
    email?: string;
    userName?: string;
}

export class CheckUserExistResult implements ICheckUserExistResult {
    isUserNameTaken?: boolean;
    isEmailTaken?: boolean;

    constructor(data?: ICheckUserExistResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameTaken = _data["isUserNameTaken"];
            this.isEmailTaken = _data["isEmailTaken"];
        }
    }

    static fromJS(data: any): CheckUserExistResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserExistResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameTaken"] = this.isUserNameTaken;
        data["isEmailTaken"] = this.isEmailTaken;
        return data;
    }
}

export interface ICheckUserExistResult {
    isUserNameTaken?: boolean;
    isEmailTaken?: boolean;
}

export class GetUserResult implements IGetUserResult {
    userName?: string;
    email?: string;

    constructor(data?: IGetUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetUserResult {
    userName?: string;
    email?: string;
}

export class BackendAPIResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class BackendAPIException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isBackendAPIException = true;

    static isBackendAPIException(obj: any): obj is BackendAPIException {
        return obj.isBackendAPIException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new BackendAPIException(message, status, response, headers, null);
}